<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>glean.metrics API documentation</title>
<meta name="description" content="This module contains all of the metric types.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>glean.metrics</code></h1>
</header>
<section id="section-intro">
<p>This module contains all of the metric types.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="glean.metrics.datetime" href="datetime.html">glean.metrics.datetime</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.event" href="event.html">glean.metrics.event</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.labeled" href="labeled.html">glean.metrics.labeled</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.object" href="object.html">glean.metrics.object</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.ping" href="ping.html">glean.metrics.ping</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.string" href="string.html">glean.metrics.string</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.timespan" href="timespan.html">glean.metrics.timespan</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.timing_distribution" href="timing_distribution.html">glean.metrics.timing_distribution</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.url" href="url.html">glean.metrics.url</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.uuid" href="uuid.html">glean.metrics.uuid</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="glean.metrics.AttributionMetrics"><code class="flex name class">
<span>class <span class="ident">AttributionMetrics</span></span>
<span>(</span><span>*,<br>source: "'typing.Optional[str]'" = &lt;object object&gt;,<br>medium: "'typing.Optional[str]'" = &lt;object object&gt;,<br>campaign: "'typing.Optional[str]'" = &lt;object object&gt;,<br>term: "'typing.Optional[str]'" = &lt;object object&gt;,<br>content: "'typing.Optional[str]'" = &lt;object object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttributionMetrics:
    source: &#34;typing.Optional[str]&#34;
    medium: &#34;typing.Optional[str]&#34;
    campaign: &#34;typing.Optional[str]&#34;
    term: &#34;typing.Optional[str]&#34;
    content: &#34;typing.Optional[str]&#34;
    def __init__(self, *, source: &#34;typing.Optional[str]&#34; = _DEFAULT, medium: &#34;typing.Optional[str]&#34; = _DEFAULT, campaign: &#34;typing.Optional[str]&#34; = _DEFAULT, term: &#34;typing.Optional[str]&#34; = _DEFAULT, content: &#34;typing.Optional[str]&#34; = _DEFAULT):
        if source is _DEFAULT:
            self.source = None
        else:
            self.source = source
        if medium is _DEFAULT:
            self.medium = None
        else:
            self.medium = medium
        if campaign is _DEFAULT:
            self.campaign = None
        else:
            self.campaign = campaign
        if term is _DEFAULT:
            self.term = None
        else:
            self.term = term
        if content is _DEFAULT:
            self.content = None
        else:
            self.content = content

    def __str__(self):
        return &#34;AttributionMetrics(source={}, medium={}, campaign={}, term={}, content={})&#34;.format(self.source, self.medium, self.campaign, self.term, self.content)

    def __eq__(self, other):
        if self.source != other.source:
            return False
        if self.medium != other.medium:
            return False
        if self.campaign != other.campaign:
            return False
        if self.term != other.term:
            return False
        if self.content != other.content:
            return False
        return True</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.AttributionMetrics.campaign"><code class="name">var <span class="ident">campaign</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.AttributionMetrics.content"><code class="name">var <span class="ident">content</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.AttributionMetrics.medium"><code class="name">var <span class="ident">medium</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.AttributionMetrics.source"><code class="name">var <span class="ident">source</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.AttributionMetrics.term"><code class="name">var <span class="ident">term</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.BooleanMetric"><code class="flex name class">
<span>class <span class="ident">BooleanMetricType</span></span>
<span>(</span><span>meta: "'<a title="glean.metrics.CommonMetricData" href="#glean.metrics.CommonMetricData">CommonMetricData</a>'")</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BooleanMetric():
    _pointer: ctypes.c_void_p
    def __init__(self, meta: &#34;CommonMetricData&#34;):
        _UniffiConverterTypeCommonMetricData.check_lower(meta)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_constructor_booleanmetric_new,
        _UniffiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, &#34;_pointer&#34;, None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_booleanmetric, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_booleanmetric, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def set(self, value: &#34;bool&#34;) -&gt; None:
        _UniffiConverterBool.check_lower(value)
        
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_set,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(value))






    def test_get_num_recorded_errors(self, error: &#34;ErrorType&#34;) -&gt; &#34;int&#34;:
        _UniffiConverterTypeErrorType.check_lower(error)
        
        return _UniffiConverterInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_test_get_num_recorded_errors,self._uniffi_clone_pointer(),
        _UniffiConverterTypeErrorType.lower(error))
        )





    def test_get_value(self, ping_name: &#34;typing.Union[object, typing.Optional[str]]&#34; = _DEFAULT) -&gt; &#34;typing.Optional[bool]&#34;:
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiConverterOptionalString.check_lower(ping_name)
        
        return _UniffiConverterOptionalBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_test_get_value,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalString.lower(ping_name))
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.BooleanMetric.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: "'bool'") ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: &#34;bool&#34;) -&gt; None:
    _UniffiConverterBool.check_lower(value)
    
    _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_set,self._uniffi_clone_pointer(),
    _UniffiConverterBool.lower(value))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.BooleanMetric.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error: "'ErrorType'") ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error: &#34;ErrorType&#34;) -&gt; &#34;int&#34;:
    _UniffiConverterTypeErrorType.check_lower(error)
    
    return _UniffiConverterInt32.lift(
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_test_get_num_recorded_errors,self._uniffi_clone_pointer(),
    _UniffiConverterTypeErrorType.lower(error))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.BooleanMetric.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self,<br>ping_name: "'typing.Union[<a title="glean.metrics.object" href="object.html">glean.metrics.object</a>, typing.Optional[str]]'" = &lt;object object&gt;) ‑> bool | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: &#34;typing.Union[object, typing.Optional[str]]&#34; = _DEFAULT) -&gt; &#34;typing.Optional[bool]&#34;:
    if ping_name is _DEFAULT:
        ping_name = None
    _UniffiConverterOptionalString.check_lower(ping_name)
    
    return _UniffiConverterOptionalBool.lift(
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_test_get_value,self._uniffi_clone_pointer(),
    _UniffiConverterOptionalString.lower(ping_name))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.CommonMetricData"><code class="flex name class">
<span>class <span class="ident">CommonMetricData</span></span>
<span>(</span><span>*,<br>category: "'str'",<br>name: "'str'",<br>send_in_pings: "'typing.List[str]'",<br>lifetime: "'<a title="glean.metrics.Lifetime" href="#glean.metrics.Lifetime">Lifetime</a>'",<br>disabled: "'bool'",<br>dynamic_label: "'typing.Optional[str]'" = &lt;object object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommonMetricData:
    category: &#34;str&#34;
    name: &#34;str&#34;
    send_in_pings: &#34;typing.List[str]&#34;
    lifetime: &#34;Lifetime&#34;
    disabled: &#34;bool&#34;
    dynamic_label: &#34;typing.Optional[str]&#34;
    def __init__(self, *, category: &#34;str&#34;, name: &#34;str&#34;, send_in_pings: &#34;typing.List[str]&#34;, lifetime: &#34;Lifetime&#34;, disabled: &#34;bool&#34;, dynamic_label: &#34;typing.Optional[str]&#34; = _DEFAULT):
        self.category = category
        self.name = name
        self.send_in_pings = send_in_pings
        self.lifetime = lifetime
        self.disabled = disabled
        if dynamic_label is _DEFAULT:
            self.dynamic_label = None
        else:
            self.dynamic_label = dynamic_label

    def __str__(self):
        return &#34;CommonMetricData(category={}, name={}, send_in_pings={}, lifetime={}, disabled={}, dynamic_label={})&#34;.format(self.category, self.name, self.send_in_pings, self.lifetime, self.disabled, self.dynamic_label)

    def __eq__(self, other):
        if self.category != other.category:
            return False
        if self.name != other.name:
            return False
        if self.send_in_pings != other.send_in_pings:
            return False
        if self.lifetime != other.lifetime:
            return False
        if self.disabled != other.disabled:
            return False
        if self.dynamic_label != other.dynamic_label:
            return False
        return True</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.CommonMetricData.category"><code class="name">var <span class="ident">category</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.CommonMetricData.disabled"><code class="name">var <span class="ident">disabled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.CommonMetricData.dynamic_label"><code class="name">var <span class="ident">dynamic_label</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.CommonMetricData.lifetime"><code class="name">var <span class="ident">lifetime</span> : glean._uniffi.glean.Lifetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.CommonMetricData.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.CommonMetricData.send_in_pings"><code class="name">var <span class="ident">send_in_pings</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.CounterMetric"><code class="flex name class">
<span>class <span class="ident">CounterMetricType</span></span>
<span>(</span><span>meta: "'<a title="glean.metrics.CommonMetricData" href="#glean.metrics.CommonMetricData">CommonMetricData</a>'")</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CounterMetric():
    _pointer: ctypes.c_void_p
    def __init__(self, meta: &#34;CommonMetricData&#34;):
        _UniffiConverterTypeCommonMetricData.check_lower(meta)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_constructor_countermetric_new,
        _UniffiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, &#34;_pointer&#34;, None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_countermetric, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_countermetric, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add(self, amount: &#34;typing.Union[object, int]&#34; = _DEFAULT) -&gt; None:
        if amount is _DEFAULT:
            amount = 1
        _UniffiConverterInt32.check_lower(amount)
        
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_countermetric_add,self._uniffi_clone_pointer(),
        _UniffiConverterInt32.lower(amount))






    def test_get_num_recorded_errors(self, error: &#34;ErrorType&#34;) -&gt; &#34;int&#34;:
        _UniffiConverterTypeErrorType.check_lower(error)
        
        return _UniffiConverterInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_countermetric_test_get_num_recorded_errors,self._uniffi_clone_pointer(),
        _UniffiConverterTypeErrorType.lower(error))
        )





    def test_get_value(self, ping_name: &#34;typing.Union[object, typing.Optional[str]]&#34; = _DEFAULT) -&gt; &#34;typing.Optional[int]&#34;:
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiConverterOptionalString.check_lower(ping_name)
        
        return _UniffiConverterOptionalInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_countermetric_test_get_value,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalString.lower(ping_name))
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.CounterMetric.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self,<br>amount: "'typing.Union[<a title="glean.metrics.object" href="object.html">glean.metrics.object</a>, int]'" = &lt;object object&gt;) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, amount: &#34;typing.Union[object, int]&#34; = _DEFAULT) -&gt; None:
    if amount is _DEFAULT:
        amount = 1
    _UniffiConverterInt32.check_lower(amount)
    
    _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_countermetric_add,self._uniffi_clone_pointer(),
    _UniffiConverterInt32.lower(amount))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.CounterMetric.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error: "'ErrorType'") ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error: &#34;ErrorType&#34;) -&gt; &#34;int&#34;:
    _UniffiConverterTypeErrorType.check_lower(error)
    
    return _UniffiConverterInt32.lift(
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_countermetric_test_get_num_recorded_errors,self._uniffi_clone_pointer(),
    _UniffiConverterTypeErrorType.lower(error))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.CounterMetric.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self,<br>ping_name: "'typing.Union[<a title="glean.metrics.object" href="object.html">glean.metrics.object</a>, typing.Optional[str]]'" = &lt;object object&gt;) ‑> int | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: &#34;typing.Union[object, typing.Optional[str]]&#34; = _DEFAULT) -&gt; &#34;typing.Optional[int]&#34;:
    if ping_name is _DEFAULT:
        ping_name = None
    _UniffiConverterOptionalString.check_lower(ping_name)
    
    return _UniffiConverterOptionalInt32.lift(
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_countermetric_test_get_value,self._uniffi_clone_pointer(),
    _UniffiConverterOptionalString.lower(ping_name))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.DatetimeMetricType"><code class="flex name class">
<span>class <span class="ident">DatetimeMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.glean.CommonMetricData,<br>time_unit: glean._uniffi.glean.TimeUnit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatetimeMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording datetime metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The datetime API only exposes the `DatetimeMetricType.set` method.
    &#34;&#34;&#34;

    def __init__(self, common_metric_data: CommonMetricData, time_unit: TimeUnit):
        self._inner = DatetimeMetric(common_metric_data, time_unit)

    def set(self, value: Optional[datetime.datetime] = None) -&gt; None:
        &#34;&#34;&#34;
        Set a datetime value, truncating it to the metric&#39;s resolution.

        Args:
            value (datetime.datetime): (default: now) The `datetime.datetime`
                value to set. If not provided, will record the current time.
        &#34;&#34;&#34;
        if value is None:
            # now at UTC -&gt; astimezone gives us a time with the local timezone.
            value = datetime.datetime.now(datetime.timezone.utc).astimezone()

        tzinfo = value.tzinfo
        if tzinfo is not None:
            utcoff = tzinfo.utcoffset(value)
            if utcoff is not None:
                offset = utcoff.seconds
            else:
                offset = 0
        else:
            offset = 0

        dt = Datetime(
            year=value.year,
            month=value.month,
            day=value.day,
            hour=value.hour,
            minute=value.minute,
            second=value.second,
            nanosecond=value.microsecond * 1000,
            offset_seconds=offset,
        )

        self._inner.set(dt)

    def test_get_value_as_str(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only, as an ISO8601 string.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (str): value of the stored metric.
        &#34;&#34;&#34;
        dt = self.test_get_value(ping_name)
        if not dt:
            return None

        return dt.isoformat()

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[datetime.datetime]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (datetime.datetime): value of the stored metric.
        &#34;&#34;&#34;
        value = self._inner.test_get_value(ping_name)
        if not value:
            return None

        tz = tzoffset(value.offset_seconds)
        dt = datetime.datetime(
            year=value.year,
            month=value.month,
            day=value.day,
            hour=value.hour,
            minute=value.minute,
            second=value.second,
            microsecond=round(value.nanosecond / 1000),
            tzinfo=tz,
        )
        return dt

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>This implements the developer facing API for recording datetime metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The datetime API only exposes the <code><a title="glean.metrics.DatetimeMetricType.set" href="#glean.metrics.DatetimeMetricType.set">DatetimeMetricType.set()</a></code> method.</p></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.DatetimeMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: datetime.datetime | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: Optional[datetime.datetime] = None) -&gt; None:
    &#34;&#34;&#34;
    Set a datetime value, truncating it to the metric&#39;s resolution.

    Args:
        value (datetime.datetime): (default: now) The `datetime.datetime`
            value to set. If not provided, will record the current time.
    &#34;&#34;&#34;
    if value is None:
        # now at UTC -&gt; astimezone gives us a time with the local timezone.
        value = datetime.datetime.now(datetime.timezone.utc).astimezone()

    tzinfo = value.tzinfo
    if tzinfo is not None:
        utcoff = tzinfo.utcoffset(value)
        if utcoff is not None:
            offset = utcoff.seconds
        else:
            offset = 0
    else:
        offset = 0

    dt = Datetime(
        year=value.year,
        month=value.month,
        day=value.day,
        hour=value.hour,
        minute=value.minute,
        second=value.second,
        nanosecond=value.microsecond * 1000,
        offset_seconds=offset,
    )

    self._inner.set(dt)</code></pre>
</details>
<div class="desc"><p>Set a datetime value, truncating it to the metric's resolution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>(default: now) The <code>datetime.datetime</code>
value to set. If not provided, will record the current time.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.DatetimeMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.glean.ErrorType) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.DatetimeMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: str | None = None) ‑> datetime.datetime | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[datetime.datetime]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (datetime.datetime): value of the stored metric.
    &#34;&#34;&#34;
    value = self._inner.test_get_value(ping_name)
    if not value:
        return None

    tz = tzoffset(value.offset_seconds)
    dt = datetime.datetime(
        year=value.year,
        month=value.month,
        day=value.day,
        hour=value.hour,
        minute=value.minute,
        second=value.second,
        microsecond=round(value.nanosecond / 1000),
        tzinfo=tz,
    )
    return dt</code></pre>
</details>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (datetime.datetime): value of the stored metric.</p></div>
</dd>
<dt id="glean.metrics.DatetimeMetricType.test_get_value_as_str"><code class="name flex">
<span>def <span class="ident">test_get_value_as_str</span></span>(<span>self, ping_name: str | None = None) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value_as_str(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only, as an ISO8601 string.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (str): value of the stored metric.
    &#34;&#34;&#34;
    dt = self.test_get_value(ping_name)
    if not dt:
        return None

    return dt.isoformat()</code></pre>
</details>
<div class="desc"><p>Returns the stored value for testing purposes only, as an ISO8601 string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (str): value of the stored metric.</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.DistributionMetrics"><code class="flex name class">
<span>class <span class="ident">DistributionMetrics</span></span>
<span>(</span><span>*, name: "'typing.Optional[str]'" = &lt;object object&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DistributionMetrics:
    name: &#34;typing.Optional[str]&#34;
    def __init__(self, *, name: &#34;typing.Optional[str]&#34; = _DEFAULT):
        if name is _DEFAULT:
            self.name = None
        else:
            self.name = name

    def __str__(self):
        return &#34;DistributionMetrics(name={})&#34;.format(self.name)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.DistributionMetrics.name"><code class="name">var <span class="ident">name</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.EventExtras"><code class="flex name class">
<span>class <span class="ident">EventExtras</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventExtras:
    &#34;&#34;&#34;
    A class that can be converted into key-value pairs of event extras.
    This will be automatically implemented for event properties of an [EventMetricType].
    &#34;&#34;&#34;

    def to_ffi_extra(self) -&gt; Dict[str, str]:
        &#34;&#34;&#34;
        Convert the event extras into a key-value dict:
        &#34;&#34;&#34;
        return {}</code></pre>
</details>
<div class="desc"><p>A class that can be converted into key-value pairs of event extras.
This will be automatically implemented for event properties of an [EventMetricType].</p></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.EventExtras.to_ffi_extra"><code class="name flex">
<span>def <span class="ident">to_ffi_extra</span></span>(<span>self) ‑> Dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_ffi_extra(self) -&gt; Dict[str, str]:
    &#34;&#34;&#34;
    Convert the event extras into a key-value dict:
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
<div class="desc"><p>Convert the event extras into a key-value dict:</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.EventMetricType"><code class="flex name class">
<span>class <span class="ident">EventMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.glean.CommonMetricData,<br>allowed_extra_keys: List[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording events.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The event API only exposes the `EventMetricType.record` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        common_metric_data: CommonMetricData,
        allowed_extra_keys: List[str],
    ):
        self._inner = EventMetric(common_metric_data, allowed_extra_keys)

    def record(self, extra: Optional[EventExtras] = None) -&gt; None:
        &#34;&#34;&#34;
        Record an event by using the information provided by the instance of
        this class.

        Args:
            extra: optional. The extra keys and values for this event.
                   The maximum length for values is 100.
        &#34;&#34;&#34;

        if isinstance(extra, EventExtras):
            inner_extra = extra.to_ffi_extra()
        else:
            inner_extra = {}

        self._inner.record(inner_extra)

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[List[RecordedEvent]]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (list of RecordedEventData): value of the stored events.
        &#34;&#34;&#34;
        # Translate NO extras into an empty dictionary,
        # to simplify handling.
        recordings = self._inner.test_get_value(ping_name)
        if recordings:
            for recording in recordings:
                if recording.extra is None:
                    recording.extra = {}

        return recordings

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>This implements the developer facing API for recording events.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The event API only exposes the <code><a title="glean.metrics.EventMetricType.record" href="#glean.metrics.EventMetricType.record">EventMetricType.record()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.</p></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.EventMetricType.record"><code class="name flex">
<span>def <span class="ident">record</span></span>(<span>self,<br>extra: <a title="glean.metrics.event.EventExtras" href="event.html#glean.metrics.event.EventExtras">EventExtras</a> | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record(self, extra: Optional[EventExtras] = None) -&gt; None:
    &#34;&#34;&#34;
    Record an event by using the information provided by the instance of
    this class.

    Args:
        extra: optional. The extra keys and values for this event.
               The maximum length for values is 100.
    &#34;&#34;&#34;

    if isinstance(extra, EventExtras):
        inner_extra = extra.to_ffi_extra()
    else:
        inner_extra = {}

    self._inner.record(inner_extra)</code></pre>
</details>
<div class="desc"><p>Record an event by using the information provided by the instance of
this class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extra</code></strong></dt>
<dd>optional. The extra keys and values for this event.
The maximum length for values is 100.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.EventMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.glean.ErrorType) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
</dd>
<dt id="glean.metrics.EventMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: str | None = None) ‑> List[glean._uniffi.glean.RecordedEvent] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[List[RecordedEvent]]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (list of RecordedEventData): value of the stored events.
    &#34;&#34;&#34;
    # Translate NO extras into an empty dictionary,
    # to simplify handling.
    recordings = self._inner.test_get_value(ping_name)
    if recordings:
        for recording in recordings:
            if recording.extra is None:
                recording.extra = {}

    return recordings</code></pre>
</details>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (list of RecordedEventData): value of the stored events.</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.LabeledBooleanMetricType"><code class="flex name class">
<span>class <span class="ident">LabeledBooleanMetricType</span></span>
<span>(</span><span>labeled_metric_data: glean._uniffi.glean.LabeledMetricData,<br>labels: Set[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledBooleanMetricType(LabeledMetricBase):
    _ctor = LabeledBoolean</code></pre>
</details>
<div class="desc"><p>This implements the developer-facing API for labeled metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>Unlike most metric types, LabeledMetricType does not have its own
corresponding storage, but records metrics for the underlying metric type T
in the storage for that type. The only difference is that labeled metrics
are stored with the special key <code>$category.$name/$label</code>. The collect
method knows how to pull these special values back out of the individual
metric storage and rearrange them correctly in the ping.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>glean.metrics.labeled.LabeledMetricBase</li>
</ul>
</dd>
<dt id="glean.metrics.LabeledCounterMetricType"><code class="flex name class">
<span>class <span class="ident">LabeledCounterMetricType</span></span>
<span>(</span><span>labeled_metric_data: glean._uniffi.glean.LabeledMetricData,<br>labels: Set[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledCounterMetricType(LabeledMetricBase):
    _ctor = LabeledCounter</code></pre>
</details>
<div class="desc"><p>This implements the developer-facing API for labeled metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>Unlike most metric types, LabeledMetricType does not have its own
corresponding storage, but records metrics for the underlying metric type T
in the storage for that type. The only difference is that labeled metrics
are stored with the special key <code>$category.$name/$label</code>. The collect
method knows how to pull these special values back out of the individual
metric storage and rearrange them correctly in the ping.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>glean.metrics.labeled.LabeledMetricBase</li>
</ul>
</dd>
<dt id="glean.metrics.LabeledMetricData"><code class="flex name class">
<span>class <span class="ident">LabeledMetricData</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledMetricData:
    def __init__(self):
        raise RuntimeError(&#34;LabeledMetricData cannot be instantiated directly&#34;)

    # Each enum variant is a nested class of the enum itself.
    class COMMON:
        cmd: &#34;CommonMetricData&#34;

        def __init__(self,cmd: &#34;CommonMetricData&#34;):
            self.cmd = cmd

        def __str__(self):
            return &#34;LabeledMetricData.COMMON(cmd={})&#34;.format(self.cmd)

        def __eq__(self, other):
            if not other.is_COMMON():
                return False
            if self.cmd != other.cmd:
                return False
            return True
    
    class CUSTOM_DISTRIBUTION:
        cmd: &#34;CommonMetricData&#34;
        range_min: &#34;int&#34;
        range_max: &#34;int&#34;
        bucket_count: &#34;int&#34;
        histogram_type: &#34;HistogramType&#34;

        def __init__(self,cmd: &#34;CommonMetricData&#34;, range_min: &#34;int&#34;, range_max: &#34;int&#34;, bucket_count: &#34;int&#34;, histogram_type: &#34;HistogramType&#34;):
            self.cmd = cmd
            self.range_min = range_min
            self.range_max = range_max
            self.bucket_count = bucket_count
            self.histogram_type = histogram_type

        def __str__(self):
            return &#34;LabeledMetricData.CUSTOM_DISTRIBUTION(cmd={}, range_min={}, range_max={}, bucket_count={}, histogram_type={})&#34;.format(self.cmd, self.range_min, self.range_max, self.bucket_count, self.histogram_type)

        def __eq__(self, other):
            if not other.is_CUSTOM_DISTRIBUTION():
                return False
            if self.cmd != other.cmd:
                return False
            if self.range_min != other.range_min:
                return False
            if self.range_max != other.range_max:
                return False
            if self.bucket_count != other.bucket_count:
                return False
            if self.histogram_type != other.histogram_type:
                return False
            return True
    
    class MEMORY_DISTRIBUTION:
        cmd: &#34;CommonMetricData&#34;
        unit: &#34;MemoryUnit&#34;

        def __init__(self,cmd: &#34;CommonMetricData&#34;, unit: &#34;MemoryUnit&#34;):
            self.cmd = cmd
            self.unit = unit

        def __str__(self):
            return &#34;LabeledMetricData.MEMORY_DISTRIBUTION(cmd={}, unit={})&#34;.format(self.cmd, self.unit)

        def __eq__(self, other):
            if not other.is_MEMORY_DISTRIBUTION():
                return False
            if self.cmd != other.cmd:
                return False
            if self.unit != other.unit:
                return False
            return True
    
    class TIMING_DISTRIBUTION:
        cmd: &#34;CommonMetricData&#34;
        unit: &#34;TimeUnit&#34;

        def __init__(self,cmd: &#34;CommonMetricData&#34;, unit: &#34;TimeUnit&#34;):
            self.cmd = cmd
            self.unit = unit

        def __str__(self):
            return &#34;LabeledMetricData.TIMING_DISTRIBUTION(cmd={}, unit={})&#34;.format(self.cmd, self.unit)

        def __eq__(self, other):
            if not other.is_TIMING_DISTRIBUTION():
                return False
            if self.cmd != other.cmd:
                return False
            if self.unit != other.unit:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_COMMON(self) -&gt; bool:
        return isinstance(self, LabeledMetricData.COMMON)
    def is_common(self) -&gt; bool:
        return isinstance(self, LabeledMetricData.COMMON)
    def is_CUSTOM_DISTRIBUTION(self) -&gt; bool:
        return isinstance(self, LabeledMetricData.CUSTOM_DISTRIBUTION)
    def is_custom_distribution(self) -&gt; bool:
        return isinstance(self, LabeledMetricData.CUSTOM_DISTRIBUTION)
    def is_MEMORY_DISTRIBUTION(self) -&gt; bool:
        return isinstance(self, LabeledMetricData.MEMORY_DISTRIBUTION)
    def is_memory_distribution(self) -&gt; bool:
        return isinstance(self, LabeledMetricData.MEMORY_DISTRIBUTION)
    def is_TIMING_DISTRIBUTION(self) -&gt; bool:
        return isinstance(self, LabeledMetricData.TIMING_DISTRIBUTION)
    def is_timing_distribution(self) -&gt; bool:
        return isinstance(self, LabeledMetricData.TIMING_DISTRIBUTION)</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>glean._uniffi.glean.LabeledMetricData.COMMON</li>
<li>glean._uniffi.glean.LabeledMetricData.CUSTOM_DISTRIBUTION</li>
<li>glean._uniffi.glean.LabeledMetricData.MEMORY_DISTRIBUTION</li>
<li>glean._uniffi.glean.LabeledMetricData.TIMING_DISTRIBUTION</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.LabeledMetricData.COMMON"><code class="name">var <span class="ident">COMMON</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.LabeledMetricData.CUSTOM_DISTRIBUTION"><code class="name">var <span class="ident">CUSTOM_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.LabeledMetricData.MEMORY_DISTRIBUTION"><code class="name">var <span class="ident">MEMORY_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.LabeledMetricData.TIMING_DISTRIBUTION"><code class="name">var <span class="ident">TIMING_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.LabeledMetricData.is_COMMON"><code class="name flex">
<span>def <span class="ident">is_COMMON</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_COMMON(self) -&gt; bool:
    return isinstance(self, LabeledMetricData.COMMON)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.LabeledMetricData.is_CUSTOM_DISTRIBUTION"><code class="name flex">
<span>def <span class="ident">is_CUSTOM_DISTRIBUTION</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_CUSTOM_DISTRIBUTION(self) -&gt; bool:
    return isinstance(self, LabeledMetricData.CUSTOM_DISTRIBUTION)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.LabeledMetricData.is_MEMORY_DISTRIBUTION"><code class="name flex">
<span>def <span class="ident">is_MEMORY_DISTRIBUTION</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_MEMORY_DISTRIBUTION(self) -&gt; bool:
    return isinstance(self, LabeledMetricData.MEMORY_DISTRIBUTION)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.LabeledMetricData.is_TIMING_DISTRIBUTION"><code class="name flex">
<span>def <span class="ident">is_TIMING_DISTRIBUTION</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_TIMING_DISTRIBUTION(self) -&gt; bool:
    return isinstance(self, LabeledMetricData.TIMING_DISTRIBUTION)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.LabeledMetricData.is_common"><code class="name flex">
<span>def <span class="ident">is_common</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_common(self) -&gt; bool:
    return isinstance(self, LabeledMetricData.COMMON)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.LabeledMetricData.is_custom_distribution"><code class="name flex">
<span>def <span class="ident">is_custom_distribution</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_custom_distribution(self) -&gt; bool:
    return isinstance(self, LabeledMetricData.CUSTOM_DISTRIBUTION)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.LabeledMetricData.is_memory_distribution"><code class="name flex">
<span>def <span class="ident">is_memory_distribution</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_memory_distribution(self) -&gt; bool:
    return isinstance(self, LabeledMetricData.MEMORY_DISTRIBUTION)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.LabeledMetricData.is_timing_distribution"><code class="name flex">
<span>def <span class="ident">is_timing_distribution</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_timing_distribution(self) -&gt; bool:
    return isinstance(self, LabeledMetricData.TIMING_DISTRIBUTION)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.LabeledQuantityMetricType"><code class="flex name class">
<span>class <span class="ident">LabeledQuantityMetricType</span></span>
<span>(</span><span>labeled_metric_data: glean._uniffi.glean.LabeledMetricData,<br>labels: Set[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledQuantityMetricType(LabeledMetricBase):
    _ctor = LabeledQuantity</code></pre>
</details>
<div class="desc"><p>This implements the developer-facing API for labeled metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>Unlike most metric types, LabeledMetricType does not have its own
corresponding storage, but records metrics for the underlying metric type T
in the storage for that type. The only difference is that labeled metrics
are stored with the special key <code>$category.$name/$label</code>. The collect
method knows how to pull these special values back out of the individual
metric storage and rearrange them correctly in the ping.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>glean.metrics.labeled.LabeledMetricBase</li>
</ul>
</dd>
<dt id="glean.metrics.LabeledStringMetricType"><code class="flex name class">
<span>class <span class="ident">LabeledStringMetricType</span></span>
<span>(</span><span>labeled_metric_data: glean._uniffi.glean.LabeledMetricData,<br>labels: Set[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledStringMetricType(LabeledMetricBase):
    _ctor = LabeledString</code></pre>
</details>
<div class="desc"><p>This implements the developer-facing API for labeled metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>Unlike most metric types, LabeledMetricType does not have its own
corresponding storage, but records metrics for the underlying metric type T
in the storage for that type. The only difference is that labeled metrics
are stored with the special key <code>$category.$name/$label</code>. The collect
method knows how to pull these special values back out of the individual
metric storage and rearrange them correctly in the ping.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>glean.metrics.labeled.LabeledMetricBase</li>
</ul>
</dd>
<dt id="glean.metrics.Lifetime"><code class="flex name class">
<span>class <span class="ident">Lifetime</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lifetime(enum.Enum):
    PING = 0
    
    APPLICATION = 1
    
    USER = 2</code></pre>
</details>
<div class="desc"><p>An enumeration.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.Lifetime.APPLICATION"><code class="name">var <span class="ident">APPLICATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.Lifetime.PING"><code class="name">var <span class="ident">PING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.Lifetime.USER"><code class="name">var <span class="ident">USER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.MemoryDistributionMetric"><code class="flex name class">
<span>class <span class="ident">MemoryDistributionMetricType</span></span>
<span>(</span><span>meta: "'<a title="glean.metrics.CommonMetricData" href="#glean.metrics.CommonMetricData">CommonMetricData</a>'",<br>memory_unit: "'<a title="glean.metrics.MemoryUnit" href="#glean.metrics.MemoryUnit">MemoryUnit</a>'")</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryDistributionMetric():
    _pointer: ctypes.c_void_p
    def __init__(self, meta: &#34;CommonMetricData&#34;,memory_unit: &#34;MemoryUnit&#34;):
        _UniffiConverterTypeCommonMetricData.check_lower(meta)
        
        _UniffiConverterTypeMemoryUnit.check_lower(memory_unit)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_constructor_memorydistributionmetric_new,
        _UniffiConverterTypeCommonMetricData.lower(meta),
        _UniffiConverterTypeMemoryUnit.lower(memory_unit))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, &#34;_pointer&#34;, None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_memorydistributionmetric, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_memorydistributionmetric, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def accumulate(self, sample: &#34;int&#34;) -&gt; None:
        _UniffiConverterInt64.check_lower(sample)
        
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_accumulate,self._uniffi_clone_pointer(),
        _UniffiConverterInt64.lower(sample))






    def accumulate_samples(self, samples: &#34;typing.List[int]&#34;) -&gt; None:
        _UniffiConverterSequenceInt64.check_lower(samples)
        
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_accumulate_samples,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceInt64.lower(samples))






    def test_get_num_recorded_errors(self, error: &#34;ErrorType&#34;) -&gt; &#34;int&#34;:
        _UniffiConverterTypeErrorType.check_lower(error)
        
        return _UniffiConverterInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_test_get_num_recorded_errors,self._uniffi_clone_pointer(),
        _UniffiConverterTypeErrorType.lower(error))
        )





    def test_get_value(self, ping_name: &#34;typing.Union[object, typing.Optional[str]]&#34; = _DEFAULT) -&gt; &#34;typing.Optional[DistributionData]&#34;:
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiConverterOptionalString.check_lower(ping_name)
        
        return _UniffiConverterOptionalTypeDistributionData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_test_get_value,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalString.lower(ping_name))
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.MemoryDistributionMetric.accumulate"><code class="name flex">
<span>def <span class="ident">accumulate</span></span>(<span>self, sample: "'int'") ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accumulate(self, sample: &#34;int&#34;) -&gt; None:
    _UniffiConverterInt64.check_lower(sample)
    
    _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_accumulate,self._uniffi_clone_pointer(),
    _UniffiConverterInt64.lower(sample))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.MemoryDistributionMetric.accumulate_samples"><code class="name flex">
<span>def <span class="ident">accumulate_samples</span></span>(<span>self, samples: "'typing.List[int]'") ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accumulate_samples(self, samples: &#34;typing.List[int]&#34;) -&gt; None:
    _UniffiConverterSequenceInt64.check_lower(samples)
    
    _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_accumulate_samples,self._uniffi_clone_pointer(),
    _UniffiConverterSequenceInt64.lower(samples))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.MemoryDistributionMetric.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error: "'ErrorType'") ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error: &#34;ErrorType&#34;) -&gt; &#34;int&#34;:
    _UniffiConverterTypeErrorType.check_lower(error)
    
    return _UniffiConverterInt32.lift(
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_test_get_num_recorded_errors,self._uniffi_clone_pointer(),
    _UniffiConverterTypeErrorType.lower(error))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.MemoryDistributionMetric.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self,<br>ping_name: "'typing.Union[<a title="glean.metrics.object" href="object.html">glean.metrics.object</a>, typing.Optional[str]]'" = &lt;object object&gt;) ‑> glean._uniffi.glean.DistributionData | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: &#34;typing.Union[object, typing.Optional[str]]&#34; = _DEFAULT) -&gt; &#34;typing.Optional[DistributionData]&#34;:
    if ping_name is _DEFAULT:
        ping_name = None
    _UniffiConverterOptionalString.check_lower(ping_name)
    
    return _UniffiConverterOptionalTypeDistributionData.lift(
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_test_get_value,self._uniffi_clone_pointer(),
    _UniffiConverterOptionalString.lower(ping_name))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.MemoryUnit"><code class="flex name class">
<span>class <span class="ident">MemoryUnit</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryUnit(enum.Enum):
    BYTE = 0
    
    KILOBYTE = 1
    
    MEGABYTE = 2
    
    GIGABYTE = 3</code></pre>
</details>
<div class="desc"><p>An enumeration.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.MemoryUnit.BYTE"><code class="name">var <span class="ident">BYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.MemoryUnit.GIGABYTE"><code class="name">var <span class="ident">GIGABYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.MemoryUnit.KILOBYTE"><code class="name">var <span class="ident">KILOBYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.MemoryUnit.MEGABYTE"><code class="name">var <span class="ident">MEGABYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.ObjectMetricType"><code class="flex name class">
<span>class <span class="ident">ObjectMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.glean.CommonMetricData, ty: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ObjectMetricType(Generic[T]):
    &#34;&#34;&#34;
    This implements the developer facing API for recording events.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The event API only exposes the `ObjectMetricType.set` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        common_metric_data: CommonMetricData,
        ty: Any,
    ):
        self._inner = ObjectMetric(common_metric_data)
        self._objty = ty

    def set(self, obj: T) -&gt; None:
        &#34;&#34;&#34;
        Set the object.
        Args:
            extra: optional. The extra keys and values for this event.
                   The maximum length for values is 100.
        &#34;&#34;&#34;

        if isinstance(obj, self._objty):
            inner_obj = obj.into_serialized_object()
            self._inner.set_string(inner_obj)
        else:
            self._inner.record_schema_error()

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[dict]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (list of RecordedEventData): value of the stored events.
        &#34;&#34;&#34;
        data = self._inner.test_get_value(ping_name)
        if data:
            return json.loads(data)

        return None

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>This implements the developer facing API for recording events.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The event API only exposes the <code><a title="glean.metrics.ObjectMetricType.set" href="#glean.metrics.ObjectMetricType.set">ObjectMetricType.set()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.ObjectMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, obj: ~T) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, obj: T) -&gt; None:
    &#34;&#34;&#34;
    Set the object.
    Args:
        extra: optional. The extra keys and values for this event.
               The maximum length for values is 100.
    &#34;&#34;&#34;

    if isinstance(obj, self._objty):
        inner_obj = obj.into_serialized_object()
        self._inner.set_string(inner_obj)
    else:
        self._inner.record_schema_error()</code></pre>
</details>
<div class="desc"><p>Set the object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extra</code></strong></dt>
<dd>optional. The extra keys and values for this event.
The maximum length for values is 100.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.ObjectMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.glean.ErrorType) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
</dd>
<dt id="glean.metrics.ObjectMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: str | None = None) ‑> dict | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[dict]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (list of RecordedEventData): value of the stored events.
    &#34;&#34;&#34;
    data = self._inner.test_get_value(ping_name)
    if data:
        return json.loads(data)

    return None</code></pre>
</details>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (list of RecordedEventData): value of the stored events.</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.ObjectSerialize"><code class="flex name class">
<span>class <span class="ident">ObjectSerialize</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ObjectSerialize:
    &#34;&#34;&#34;
    A class that can be converted into key-value pairs of event extras.
    This will be automatically implemented for event properties of an [ObjectMetricType].
    &#34;&#34;&#34;

    def into_serialized_object(self) -&gt; str:
        &#34;&#34;&#34;
        Convert the event extras into a key-value dict:
        &#34;&#34;&#34;
        return json.dumps(self, cls=EncodeObject)</code></pre>
</details>
<div class="desc"><p>A class that can be converted into key-value pairs of event extras.
This will be automatically implemented for event properties of an [ObjectMetricType].</p></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.ObjectSerialize.into_serialized_object"><code class="name flex">
<span>def <span class="ident">into_serialized_object</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def into_serialized_object(self) -&gt; str:
    &#34;&#34;&#34;
    Convert the event extras into a key-value dict:
    &#34;&#34;&#34;
    return json.dumps(self, cls=EncodeObject)</code></pre>
</details>
<div class="desc"><p>Convert the event extras into a key-value dict:</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.PingType"><code class="flex name class">
<span>class <span class="ident">PingType</span></span>
<span>(</span><span>name: str,<br>include_client_id: bool,<br>send_if_empty: bool,<br>precise_timestamps: bool,<br>include_info_sections: bool,<br>schedules_pings: List[str],<br>reason_codes: List[str],<br>uploader_capabilities: List[str],<br>enabled: bool = True,<br>follows_collection_enabled: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PingType:
    def __init__(
        self,
        name: str,
        include_client_id: bool,
        send_if_empty: bool,
        precise_timestamps: bool,
        include_info_sections: bool,
        schedules_pings: List[str],
        reason_codes: List[str],
        uploader_capabilities: List[str],
        enabled: bool = True,
        follows_collection_enabled: bool = True,
    ):
        &#34;&#34;&#34;
        This implements the developer facing API for custom pings.

        The Ping API only exposes the `PingType.submit` method, which schedules a
        ping for eventual uploading.
        &#34;&#34;&#34;
        self._reason_codes = reason_codes
        self._inner = GleanPingType(
            name,
            include_client_id,
            send_if_empty,
            precise_timestamps,
            include_info_sections,
            enabled,
            schedules_pings,
            reason_codes,
            follows_collection_enabled,
            uploader_capabilities,
        )
        self._test_callback = None  # type: Optional[Callable[[Optional[str]], None]]

    def test_before_next_submit(self, cb: Callable[[Optional[str]], None]):
        &#34;&#34;&#34;
        **Test-only API**

        Attach a callback to be called right before a new ping is submitted.
        The provided function is called exactly once before submitting a ping.

        Note: The callback will be called on any call to submit.
        A ping might not be sent afterwards, e.g. if the ping is otherwise empty (and
        `send_if_empty` is `False`).
        &#34;&#34;&#34;
        self._test_callback = cb

    def submit(self, reason: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Collect and submit the ping for eventual uploading.

        If the ping currently contains no content, it will not be sent.

        Args:
            reason (enum, optional): The reason the ping was submitted.
        &#34;&#34;&#34;
        reason_string: Optional[str] = None
        if reason is not None:
            reason_string = self._reason_codes[reason]
        else:
            reason_string = None

        if self._test_callback is not None:
            self._test_callback(reason_string)
            self._test_callback = None

        self._inner.submit(reason_string)

    def set_enabled(self, enabled: bool) -&gt; None:
        &#34;&#34;&#34;
        Enable or disable a ping.

        Disabling a ping causes all data for that ping to be removed from storage
        and all pending pings of that type to be deleted.
        &#34;&#34;&#34;
        self._inner.set_enabled(enabled)</code></pre>
</details>
<div class="desc"><p>This implements the developer facing API for custom pings.</p>
<p>The Ping API only exposes the <code><a title="glean.metrics.PingType.submit" href="#glean.metrics.PingType.submit">PingType.submit()</a></code> method, which schedules a
ping for eventual uploading.</p></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.PingType.set_enabled"><code class="name flex">
<span>def <span class="ident">set_enabled</span></span>(<span>self, enabled: bool) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enabled(self, enabled: bool) -&gt; None:
    &#34;&#34;&#34;
    Enable or disable a ping.

    Disabling a ping causes all data for that ping to be removed from storage
    and all pending pings of that type to be deleted.
    &#34;&#34;&#34;
    self._inner.set_enabled(enabled)</code></pre>
</details>
<div class="desc"><p>Enable or disable a ping.</p>
<p>Disabling a ping causes all data for that ping to be removed from storage
and all pending pings of that type to be deleted.</p></div>
</dd>
<dt id="glean.metrics.PingType.submit"><code class="name flex">
<span>def <span class="ident">submit</span></span>(<span>self, reason: int | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit(self, reason: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Collect and submit the ping for eventual uploading.

    If the ping currently contains no content, it will not be sent.

    Args:
        reason (enum, optional): The reason the ping was submitted.
    &#34;&#34;&#34;
    reason_string: Optional[str] = None
    if reason is not None:
        reason_string = self._reason_codes[reason]
    else:
        reason_string = None

    if self._test_callback is not None:
        self._test_callback(reason_string)
        self._test_callback = None

    self._inner.submit(reason_string)</code></pre>
</details>
<div class="desc"><p>Collect and submit the ping for eventual uploading.</p>
<p>If the ping currently contains no content, it will not be sent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code>enum</code>, optional</dt>
<dd>The reason the ping was submitted.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.PingType.test_before_next_submit"><code class="name flex">
<span>def <span class="ident">test_before_next_submit</span></span>(<span>self, cb: Callable[[str | None], None])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_before_next_submit(self, cb: Callable[[Optional[str]], None]):
    &#34;&#34;&#34;
    **Test-only API**

    Attach a callback to be called right before a new ping is submitted.
    The provided function is called exactly once before submitting a ping.

    Note: The callback will be called on any call to submit.
    A ping might not be sent afterwards, e.g. if the ping is otherwise empty (and
    `send_if_empty` is `False`).
    &#34;&#34;&#34;
    self._test_callback = cb</code></pre>
</details>
<div class="desc"><p><strong>Test-only API</strong></p>
<p>Attach a callback to be called right before a new ping is submitted.
The provided function is called exactly once before submitting a ping.</p>
<p>Note: The callback will be called on any call to submit.
A ping might not be sent afterwards, e.g. if the ping is otherwise empty (and
<code>send_if_empty</code> is <code>False</code>).</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.QuantityMetric"><code class="flex name class">
<span>class <span class="ident">QuantityMetricType</span></span>
<span>(</span><span>meta: "'<a title="glean.metrics.CommonMetricData" href="#glean.metrics.CommonMetricData">CommonMetricData</a>'")</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuantityMetric():
    _pointer: ctypes.c_void_p
    def __init__(self, meta: &#34;CommonMetricData&#34;):
        _UniffiConverterTypeCommonMetricData.check_lower(meta)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_constructor_quantitymetric_new,
        _UniffiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, &#34;_pointer&#34;, None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_quantitymetric, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_quantitymetric, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def set(self, value: &#34;int&#34;) -&gt; None:
        _UniffiConverterInt64.check_lower(value)
        
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_set,self._uniffi_clone_pointer(),
        _UniffiConverterInt64.lower(value))






    def test_get_num_recorded_errors(self, error: &#34;ErrorType&#34;) -&gt; &#34;int&#34;:
        _UniffiConverterTypeErrorType.check_lower(error)
        
        return _UniffiConverterInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_test_get_num_recorded_errors,self._uniffi_clone_pointer(),
        _UniffiConverterTypeErrorType.lower(error))
        )





    def test_get_value(self, ping_name: &#34;typing.Union[object, typing.Optional[str]]&#34; = _DEFAULT) -&gt; &#34;typing.Optional[int]&#34;:
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiConverterOptionalString.check_lower(ping_name)
        
        return _UniffiConverterOptionalInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_test_get_value,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalString.lower(ping_name))
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.QuantityMetric.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: "'int'") ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: &#34;int&#34;) -&gt; None:
    _UniffiConverterInt64.check_lower(value)
    
    _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_set,self._uniffi_clone_pointer(),
    _UniffiConverterInt64.lower(value))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.QuantityMetric.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error: "'ErrorType'") ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error: &#34;ErrorType&#34;) -&gt; &#34;int&#34;:
    _UniffiConverterTypeErrorType.check_lower(error)
    
    return _UniffiConverterInt32.lift(
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_test_get_num_recorded_errors,self._uniffi_clone_pointer(),
    _UniffiConverterTypeErrorType.lower(error))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.QuantityMetric.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self,<br>ping_name: "'typing.Union[<a title="glean.metrics.object" href="object.html">glean.metrics.object</a>, typing.Optional[str]]'" = &lt;object object&gt;) ‑> int | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: &#34;typing.Union[object, typing.Optional[str]]&#34; = _DEFAULT) -&gt; &#34;typing.Optional[int]&#34;:
    if ping_name is _DEFAULT:
        ping_name = None
    _UniffiConverterOptionalString.check_lower(ping_name)
    
    return _UniffiConverterOptionalInt64.lift(
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_test_get_value,self._uniffi_clone_pointer(),
    _UniffiConverterOptionalString.lower(ping_name))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.RecordedEvent"><code class="flex name class">
<span>class <span class="ident">RecordedEvent</span></span>
<span>(</span><span>*,<br>timestamp: "'int'",<br>category: "'str'",<br>name: "'str'",<br>extra: "'typing.Optional[dict[str, str]]'")</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecordedEvent:
    timestamp: &#34;int&#34;
    category: &#34;str&#34;
    name: &#34;str&#34;
    extra: &#34;typing.Optional[dict[str, str]]&#34;
    def __init__(self, *, timestamp: &#34;int&#34;, category: &#34;str&#34;, name: &#34;str&#34;, extra: &#34;typing.Optional[dict[str, str]]&#34;):
        self.timestamp = timestamp
        self.category = category
        self.name = name
        self.extra = extra

    def __str__(self):
        return &#34;RecordedEvent(timestamp={}, category={}, name={}, extra={})&#34;.format(self.timestamp, self.category, self.name, self.extra)

    def __eq__(self, other):
        if self.timestamp != other.timestamp:
            return False
        if self.category != other.category:
            return False
        if self.name != other.name:
            return False
        if self.extra != other.extra:
            return False
        return True</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.RecordedEvent.category"><code class="name">var <span class="ident">category</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.RecordedEvent.extra"><code class="name">var <span class="ident">extra</span> : dict[str, str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.RecordedEvent.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.RecordedEvent.timestamp"><code class="name">var <span class="ident">timestamp</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.RecordedExperiment"><code class="flex name class">
<span>class <span class="ident">RecordedExperiment</span></span>
<span>(</span><span>*, branch: "'str'", extra: "'typing.Optional[dict[str, str]]'")</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecordedExperiment:
    branch: &#34;str&#34;
    extra: &#34;typing.Optional[dict[str, str]]&#34;
    def __init__(self, *, branch: &#34;str&#34;, extra: &#34;typing.Optional[dict[str, str]]&#34;):
        self.branch = branch
        self.extra = extra

    def __str__(self):
        return &#34;RecordedExperiment(branch={}, extra={})&#34;.format(self.branch, self.extra)

    def __eq__(self, other):
        if self.branch != other.branch:
            return False
        if self.extra != other.extra:
            return False
        return True</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.RecordedExperiment.branch"><code class="name">var <span class="ident">branch</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.RecordedExperiment.extra"><code class="name">var <span class="ident">extra</span> : dict[str, str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.StringListMetric"><code class="flex name class">
<span>class <span class="ident">StringListMetricType</span></span>
<span>(</span><span>meta: "'<a title="glean.metrics.CommonMetricData" href="#glean.metrics.CommonMetricData">CommonMetricData</a>'")</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringListMetric():
    _pointer: ctypes.c_void_p
    def __init__(self, meta: &#34;CommonMetricData&#34;):
        _UniffiConverterTypeCommonMetricData.check_lower(meta)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_constructor_stringlistmetric_new,
        _UniffiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, &#34;_pointer&#34;, None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_stringlistmetric, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_stringlistmetric, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add(self, value: &#34;str&#34;) -&gt; None:
        _UniffiConverterString.check_lower(value)
        
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_add,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(value))






    def set(self, value: &#34;typing.List[str]&#34;) -&gt; None:
        _UniffiConverterSequenceString.check_lower(value)
        
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_set,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(value))






    def test_get_num_recorded_errors(self, error: &#34;ErrorType&#34;) -&gt; &#34;int&#34;:
        _UniffiConverterTypeErrorType.check_lower(error)
        
        return _UniffiConverterInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_test_get_num_recorded_errors,self._uniffi_clone_pointer(),
        _UniffiConverterTypeErrorType.lower(error))
        )





    def test_get_value(self, ping_name: &#34;typing.Union[object, typing.Optional[str]]&#34; = _DEFAULT) -&gt; &#34;typing.Optional[typing.List[str]]&#34;:
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiConverterOptionalString.check_lower(ping_name)
        
        return _UniffiConverterOptionalSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_test_get_value,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalString.lower(ping_name))
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.StringListMetric.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, value: "'str'") ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, value: &#34;str&#34;) -&gt; None:
    _UniffiConverterString.check_lower(value)
    
    _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_add,self._uniffi_clone_pointer(),
    _UniffiConverterString.lower(value))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.StringListMetric.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: "'typing.List[str]'") ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: &#34;typing.List[str]&#34;) -&gt; None:
    _UniffiConverterSequenceString.check_lower(value)
    
    _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_set,self._uniffi_clone_pointer(),
    _UniffiConverterSequenceString.lower(value))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.StringListMetric.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error: "'ErrorType'") ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error: &#34;ErrorType&#34;) -&gt; &#34;int&#34;:
    _UniffiConverterTypeErrorType.check_lower(error)
    
    return _UniffiConverterInt32.lift(
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_test_get_num_recorded_errors,self._uniffi_clone_pointer(),
    _UniffiConverterTypeErrorType.lower(error))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.StringListMetric.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self,<br>ping_name: "'typing.Union[<a title="glean.metrics.object" href="object.html">glean.metrics.object</a>, typing.Optional[str]]'" = &lt;object object&gt;) ‑> List[str] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: &#34;typing.Union[object, typing.Optional[str]]&#34; = _DEFAULT) -&gt; &#34;typing.Optional[typing.List[str]]&#34;:
    if ping_name is _DEFAULT:
        ping_name = None
    _UniffiConverterOptionalString.check_lower(ping_name)
    
    return _UniffiConverterOptionalSequenceString.lift(
        _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_test_get_value,self._uniffi_clone_pointer(),
    _UniffiConverterOptionalString.lower(ping_name))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.StringMetricType"><code class="flex name class">
<span>class <span class="ident">StringMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.glean.CommonMetricData)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording string metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The string API only exposes the `StringMetricType.set` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(self, common_metric_data: CommonMetricData):
        self._inner = StringMetric(common_metric_data)

    def set(self, value: str) -&gt; None:
        &#34;&#34;&#34;
        Set a string value.

        Args:
            value (str): This is a user-defined string value. If the length of
                the string exceeds the maximum length, it will be truncated.
        &#34;&#34;&#34;
        if value is None:
            return

        self._inner.set(value)

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
        return self._inner.test_get_value(ping_name)

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>This implements the developer facing API for recording string metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The string API only exposes the <code><a title="glean.metrics.StringMetricType.set" href="#glean.metrics.StringMetricType.set">StringMetricType.set()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.</p></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.StringMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: str) -&gt; None:
    &#34;&#34;&#34;
    Set a string value.

    Args:
        value (str): This is a user-defined string value. If the length of
            the string exceeds the maximum length, it will be truncated.
    &#34;&#34;&#34;
    if value is None:
        return

    self._inner.set(value)</code></pre>
</details>
<div class="desc"><p>Set a string value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>This is a user-defined string value. If the length of
the string exceeds the maximum length, it will be truncated.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.StringMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.glean.ErrorType) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.StringMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: str | None = None) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
    return self._inner.test_get_value(ping_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.TimeUnit"><code class="flex name class">
<span>class <span class="ident">TimeUnit</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeUnit(enum.Enum):
    NANOSECOND = 0
    
    MICROSECOND = 1
    
    MILLISECOND = 2
    
    SECOND = 3
    
    MINUTE = 4
    
    HOUR = 5
    
    DAY = 6</code></pre>
</details>
<div class="desc"><p>An enumeration.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.TimeUnit.DAY"><code class="name">var <span class="ident">DAY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.HOUR"><code class="name">var <span class="ident">HOUR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.MICROSECOND"><code class="name">var <span class="ident">MICROSECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.MILLISECOND"><code class="name">var <span class="ident">MILLISECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.MINUTE"><code class="name">var <span class="ident">MINUTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.NANOSECOND"><code class="name">var <span class="ident">NANOSECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.SECOND"><code class="name">var <span class="ident">SECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.TimerId"><code class="flex name class">
<span>class <span class="ident">TimerId</span></span>
<span>(</span><span>*, id: "'int'")</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimerId:
    id: &#34;int&#34;
    def __init__(self, *, id: &#34;int&#34;):
        self.id = id

    def __str__(self):
        return &#34;TimerId(id={})&#34;.format(self.id)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        return True</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.TimerId.id"><code class="name">var <span class="ident">id</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.TimespanMetricType"><code class="flex name class">
<span>class <span class="ident">TimespanMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.glean.CommonMetricData,<br>time_unit: glean._uniffi.glean.TimeUnit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimespanMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording timespan metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The timespan API exposes the `TimespanMetricType.start`,
    `TimespanMetricType.stop` and `TimespanMetricType.cancel` methods.
    &#34;&#34;&#34;

    def __init__(
        self,
        common_metric_data: CommonMetricData,
        time_unit: TimeUnit,
    ):
        self._inner = TimespanMetric(common_metric_data, time_unit)

    def start(self) -&gt; None:
        &#34;&#34;&#34;
        Start tracking time for the provided metric.

        This records an error if it’s already tracking time (i.e. `start` was
        already called with no corresponding `stop`): in that case the original
        start time will be preserved.
        &#34;&#34;&#34;
        self._inner.start()

    def stop(self) -&gt; None:
        &#34;&#34;&#34;
        Stop tracking time for the provided metric.

        Sets the metric to the elapsed time, but does not overwrite an already
        existing value.
        This will record an error if no `start` was called or there is an already
        existing value.
        &#34;&#34;&#34;
        self._inner.stop()

    def cancel(self) -&gt; None:
        &#34;&#34;&#34;
        Abort a previous `start` call. No error is recorded if no `start` was called.
        &#34;&#34;&#34;
        self._inner.cancel()

    class _TimespanContextManager:
        &#34;&#34;&#34;
        A context manager for recording timings. Used by the `measure` method.
        &#34;&#34;&#34;

        def __init__(self, timespan: &#34;TimespanMetricType&#34;):
            self._timespan = timespan

        def __enter__(self) -&gt; None:
            self._timespan.start()

        def __exit__(self, type, value, tb) -&gt; None:
            if tb is None:
                self._timespan.stop()
            else:
                self._timespan.cancel()

    def measure(self) -&gt; &#34;_TimespanContextManager&#34;:
        &#34;&#34;&#34;
        Provides a context manager for measuring the time it takes to execute
        snippets of code in a `with` statement.

        If the contents of the `with` statement raise an exception, the timing
        is not recorded.

        Usage:
            with metrics.perf.timer.measure():
                # ... do something that takes time ...
        &#34;&#34;&#34;
        return self._TimespanContextManager(self)

    def set_raw_nanos(self, elapsed_nanos: int) -&gt; None:
        &#34;&#34;&#34;
        Explicitly set the timespan value, in nanoseconds.

        This API should only be used if your library or application requires recording
        times in a way that can not make use of [start]/[stop]/[cancel].

        [setRawNanos] does not overwrite a running timer or an already existing value.

        Args:
            elapsed_nanos (int): The elapsed time to record, in nanoseconds.
        &#34;&#34;&#34;
        self._inner.set_raw_nanos(elapsed_nanos)

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (bool): value of the stored metric.
        &#34;&#34;&#34;
        return self._inner.test_get_value(ping_name)

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>This implements the developer facing API for recording timespan metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The timespan API exposes the <code><a title="glean.metrics.TimespanMetricType.start" href="#glean.metrics.TimespanMetricType.start">TimespanMetricType.start()</a></code>,
<code><a title="glean.metrics.TimespanMetricType.stop" href="#glean.metrics.TimespanMetricType.stop">TimespanMetricType.stop()</a></code> and <code><a title="glean.metrics.TimespanMetricType.cancel" href="#glean.metrics.TimespanMetricType.cancel">TimespanMetricType.cancel()</a></code> methods.</p></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.TimespanMetricType.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self) -&gt; None:
    &#34;&#34;&#34;
    Abort a previous `start` call. No error is recorded if no `start` was called.
    &#34;&#34;&#34;
    self._inner.cancel()</code></pre>
</details>
<div class="desc"><p>Abort a previous <code>start</code> call. No error is recorded if no <code>start</code> was called.</p></div>
</dd>
<dt id="glean.metrics.TimespanMetricType.measure"><code class="name flex">
<span>def <span class="ident">measure</span></span>(<span>self) ‑> _TimespanContextManager</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def measure(self) -&gt; &#34;_TimespanContextManager&#34;:
    &#34;&#34;&#34;
    Provides a context manager for measuring the time it takes to execute
    snippets of code in a `with` statement.

    If the contents of the `with` statement raise an exception, the timing
    is not recorded.

    Usage:
        with metrics.perf.timer.measure():
            # ... do something that takes time ...
    &#34;&#34;&#34;
    return self._TimespanContextManager(self)</code></pre>
</details>
<div class="desc"><p>Provides a context manager for measuring the time it takes to execute
snippets of code in a <code>with</code> statement.</p>
<p>If the contents of the <code>with</code> statement raise an exception, the timing
is not recorded.</p>
<h2 id="usage">Usage</h2>
<p>with metrics.perf.timer.measure():
# &hellip; do something that takes time &hellip;</p></div>
</dd>
<dt id="glean.metrics.TimespanMetricType.set_raw_nanos"><code class="name flex">
<span>def <span class="ident">set_raw_nanos</span></span>(<span>self, elapsed_nanos: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_raw_nanos(self, elapsed_nanos: int) -&gt; None:
    &#34;&#34;&#34;
    Explicitly set the timespan value, in nanoseconds.

    This API should only be used if your library or application requires recording
    times in a way that can not make use of [start]/[stop]/[cancel].

    [setRawNanos] does not overwrite a running timer or an already existing value.

    Args:
        elapsed_nanos (int): The elapsed time to record, in nanoseconds.
    &#34;&#34;&#34;
    self._inner.set_raw_nanos(elapsed_nanos)</code></pre>
</details>
<div class="desc"><p>Explicitly set the timespan value, in nanoseconds.</p>
<p>This API should only be used if your library or application requires recording
times in a way that can not make use of [start]/[stop]/[cancel].</p>
<p>[setRawNanos] does not overwrite a running timer or an already existing value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elapsed_nanos</code></strong> :&ensp;<code>int</code></dt>
<dd>The elapsed time to record, in nanoseconds.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.TimespanMetricType.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; None:
    &#34;&#34;&#34;
    Start tracking time for the provided metric.

    This records an error if it’s already tracking time (i.e. `start` was
    already called with no corresponding `stop`): in that case the original
    start time will be preserved.
    &#34;&#34;&#34;
    self._inner.start()</code></pre>
</details>
<div class="desc"><p>Start tracking time for the provided metric.</p>
<p>This records an error if it’s already tracking time (i.e. <code>start</code> was
already called with no corresponding <code>stop</code>): in that case the original
start time will be preserved.</p></div>
</dd>
<dt id="glean.metrics.TimespanMetricType.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self) -&gt; None:
    &#34;&#34;&#34;
    Stop tracking time for the provided metric.

    Sets the metric to the elapsed time, but does not overwrite an already
    existing value.
    This will record an error if no `start` was called or there is an already
    existing value.
    &#34;&#34;&#34;
    self._inner.stop()</code></pre>
</details>
<div class="desc"><p>Stop tracking time for the provided metric.</p>
<p>Sets the metric to the elapsed time, but does not overwrite an already
existing value.
This will record an error if no <code>start</code> was called or there is an already
existing value.</p></div>
</dd>
<dt id="glean.metrics.TimespanMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.glean.ErrorType) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
</dd>
<dt id="glean.metrics.TimespanMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: str | None = None) ‑> int | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[int]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (bool): value of the stored metric.
    &#34;&#34;&#34;
    return self._inner.test_get_value(ping_name)</code></pre>
</details>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (bool): value of the stored metric.</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType"><code class="flex name class">
<span>class <span class="ident">TimingDistributionMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.glean.CommonMetricData,<br>time_unit: glean._uniffi.glean.TimeUnit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimingDistributionMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording timing distribution
    metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.
    &#34;&#34;&#34;

    def __init__(
        self,
        common_metric_data: CommonMetricData,
        time_unit: TimeUnit,
    ):
        self._inner = TimingDistributionMetric(common_metric_data, time_unit)

    def start(self) -&gt; TimerId:
        &#34;&#34;&#34;
        Start tracking time for the provided metric.
        Multiple timers can run simultaneously.

        Returns:
            timer_id: The object to associate with this timing.
        &#34;&#34;&#34;
        return self._inner.start()

    def stop_and_accumulate(self, timer_id: TimerId) -&gt; None:
        &#34;&#34;&#34;
        Stop tracking time for the provided metric and associated timer id. Add a
        count to the corresponding bucket in the timing distribution.
        This will record an error if no `start` was called.

        Args:
            timer_id: The timer id associated with this timing. This allows for
                concurrent timing of events associated with different ids to
                the same timespan metric.
        &#34;&#34;&#34;
        self._inner.stop_and_accumulate(timer_id)

    def cancel(self, timer_id: TimerId) -&gt; None:
        &#34;&#34;&#34;
        Abort a previous `start` call. No error is recorded if no `start` was called.

        Args:
            timer_id: The timer id associated with this timing. This allows for
                concurrent timing of events associated with different ids to
                the same timing distribution metric.
        &#34;&#34;&#34;
        self._inner.cancel(timer_id)

    def accumulate_samples(self, samples: list) -&gt; None:
        &#34;&#34;&#34;
        Accumulates the provided samples in the metric.

        Args:
            samples: The list holding the samples to be recorded by the metric.
        &#34;&#34;&#34;
        self._inner.accumulate_samples(samples)

    def accumulate_single_sample(self, sample: int) -&gt; None:
        &#34;&#34;&#34;
        Accumulates a single sample and appends it to the metric.

        Args:
            sample: The single sample to be recorded by the metric.
        &#34;&#34;&#34;
        self._inner.accumulate_single_sample(sample)

    class _TimingDistributionContextManager:
        &#34;&#34;&#34;
        A context manager for recording timings. Used by the `measure` method.
        &#34;&#34;&#34;

        def __init__(self, timing_distribution: &#34;TimingDistributionMetricType&#34;):
            self._timing_distribution = timing_distribution

        def __enter__(self) -&gt; None:
            self._timer_id = self._timing_distribution.start()

        def __exit__(self, type, value, tb) -&gt; None:
            if tb is None:
                self._timing_distribution.stop_and_accumulate(self._timer_id)
            else:
                self._timing_distribution.cancel(self._timer_id)

    def measure(self) -&gt; &#34;_TimingDistributionContextManager&#34;:
        &#34;&#34;&#34;
        Provides a context manager for measuring the time it takes to execute
        snippets of code in a `with` statement.

        If the contents of the `with` statement raise an exception, the timing
        is not recorded.

        Usage:
            with metrics.perf.timer.measure():
                # ... do something that takes time ...
        &#34;&#34;&#34;
        return self._TimingDistributionContextManager(self)

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[DistributionData]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (DistriubutionData): value of the stored metric.
        &#34;&#34;&#34;
        return self._inner.test_get_value(ping_name)

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>This implements the developer facing API for recording timing distribution
metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.TimingDistributionMetricType.accumulate_samples"><code class="name flex">
<span>def <span class="ident">accumulate_samples</span></span>(<span>self, samples: list) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accumulate_samples(self, samples: list) -&gt; None:
    &#34;&#34;&#34;
    Accumulates the provided samples in the metric.

    Args:
        samples: The list holding the samples to be recorded by the metric.
    &#34;&#34;&#34;
    self._inner.accumulate_samples(samples)</code></pre>
</details>
<div class="desc"><p>Accumulates the provided samples in the metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>samples</code></strong></dt>
<dd>The list holding the samples to be recorded by the metric.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.accumulate_single_sample"><code class="name flex">
<span>def <span class="ident">accumulate_single_sample</span></span>(<span>self, sample: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accumulate_single_sample(self, sample: int) -&gt; None:
    &#34;&#34;&#34;
    Accumulates a single sample and appends it to the metric.

    Args:
        sample: The single sample to be recorded by the metric.
    &#34;&#34;&#34;
    self._inner.accumulate_single_sample(sample)</code></pre>
</details>
<div class="desc"><p>Accumulates a single sample and appends it to the metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample</code></strong></dt>
<dd>The single sample to be recorded by the metric.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, timer_id: glean._uniffi.glean.TimerId) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, timer_id: TimerId) -&gt; None:
    &#34;&#34;&#34;
    Abort a previous `start` call. No error is recorded if no `start` was called.

    Args:
        timer_id: The timer id associated with this timing. This allows for
            concurrent timing of events associated with different ids to
            the same timing distribution metric.
    &#34;&#34;&#34;
    self._inner.cancel(timer_id)</code></pre>
</details>
<div class="desc"><p>Abort a previous <code>start</code> call. No error is recorded if no <code>start</code> was called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timer_id</code></strong></dt>
<dd>The timer id associated with this timing. This allows for
concurrent timing of events associated with different ids to
the same timing distribution metric.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.measure"><code class="name flex">
<span>def <span class="ident">measure</span></span>(<span>self) ‑> _TimingDistributionContextManager</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def measure(self) -&gt; &#34;_TimingDistributionContextManager&#34;:
    &#34;&#34;&#34;
    Provides a context manager for measuring the time it takes to execute
    snippets of code in a `with` statement.

    If the contents of the `with` statement raise an exception, the timing
    is not recorded.

    Usage:
        with metrics.perf.timer.measure():
            # ... do something that takes time ...
    &#34;&#34;&#34;
    return self._TimingDistributionContextManager(self)</code></pre>
</details>
<div class="desc"><p>Provides a context manager for measuring the time it takes to execute
snippets of code in a <code>with</code> statement.</p>
<p>If the contents of the <code>with</code> statement raise an exception, the timing
is not recorded.</p>
<h2 id="usage">Usage</h2>
<p>with metrics.perf.timer.measure():
# &hellip; do something that takes time &hellip;</p></div>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> glean._uniffi.glean.TimerId</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; TimerId:
    &#34;&#34;&#34;
    Start tracking time for the provided metric.
    Multiple timers can run simultaneously.

    Returns:
        timer_id: The object to associate with this timing.
    &#34;&#34;&#34;
    return self._inner.start()</code></pre>
</details>
<div class="desc"><p>Start tracking time for the provided metric.
Multiple timers can run simultaneously.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>timer_id</code></dt>
<dd>The object to associate with this timing.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.stop_and_accumulate"><code class="name flex">
<span>def <span class="ident">stop_and_accumulate</span></span>(<span>self, timer_id: glean._uniffi.glean.TimerId) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_and_accumulate(self, timer_id: TimerId) -&gt; None:
    &#34;&#34;&#34;
    Stop tracking time for the provided metric and associated timer id. Add a
    count to the corresponding bucket in the timing distribution.
    This will record an error if no `start` was called.

    Args:
        timer_id: The timer id associated with this timing. This allows for
            concurrent timing of events associated with different ids to
            the same timespan metric.
    &#34;&#34;&#34;
    self._inner.stop_and_accumulate(timer_id)</code></pre>
</details>
<div class="desc"><p>Stop tracking time for the provided metric and associated timer id. Add a
count to the corresponding bucket in the timing distribution.
This will record an error if no <code>start</code> was called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timer_id</code></strong></dt>
<dd>The timer id associated with this timing. This allows for
concurrent timing of events associated with different ids to
the same timespan metric.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.glean.ErrorType) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: str | None = None) ‑> glean._uniffi.glean.DistributionData | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[DistributionData]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (DistriubutionData): value of the stored metric.
    &#34;&#34;&#34;
    return self._inner.test_get_value(ping_name)</code></pre>
</details>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (DistriubutionData): value of the stored metric.</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.UrlMetricType"><code class="flex name class">
<span>class <span class="ident">UrlMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.glean.CommonMetricData)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UrlMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording URL metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The url API only exposes the `UrlMetricType.set` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    See https://mozilla.github.io/glean/book/reference/metrics/url.html#limits
    &#34;&#34;&#34;

    def __init__(self, common_metric_data: CommonMetricData):
        self._inner = UrlMetric(common_metric_data)

    def set(self, value: str) -&gt; None:
        &#34;&#34;&#34;
        Set a URL value.

        Args:
            value (str): This is a user-defined URL value. If the length of
                the URL exceeds the maximum length, it will not be recorded.
        &#34;&#34;&#34;
        if value is None:
            return

        self._inner.set(value)

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
        return self._inner.test_get_value(ping_name)

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>This implements the developer facing API for recording URL metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The url API only exposes the <code><a title="glean.metrics.UrlMetricType.set" href="#glean.metrics.UrlMetricType.set">UrlMetricType.set()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.
See <a href="https://mozilla.github.io/glean/book/reference/metrics/url.html#limits">https://mozilla.github.io/glean/book/reference/metrics/url.html#limits</a></p></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.UrlMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: str) -&gt; None:
    &#34;&#34;&#34;
    Set a URL value.

    Args:
        value (str): This is a user-defined URL value. If the length of
            the URL exceeds the maximum length, it will not be recorded.
    &#34;&#34;&#34;
    if value is None:
        return

    self._inner.set(value)</code></pre>
</details>
<div class="desc"><p>Set a URL value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>This is a user-defined URL value. If the length of
the URL exceeds the maximum length, it will not be recorded.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.UrlMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.glean.ErrorType) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.UrlMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: str | None = None) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
    return self._inner.test_get_value(ping_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.UuidMetricType"><code class="flex name class">
<span>class <span class="ident">UuidMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.glean.CommonMetricData)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UuidMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording UUID metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The UUID API exposes the `UuidMetricType.generate_and_set` and
    `UuidMetricType.set` methods.
    &#34;&#34;&#34;

    def __init__(self, common_metric_data: CommonMetricData):
        self._inner = UuidMetric(common_metric_data)

    def generate_and_set(self) -&gt; Optional[uuid.UUID]:
        &#34;&#34;&#34;
        Generate a new UUID value and set it in the metric store.
        &#34;&#34;&#34;
        id = self._inner.generate_and_set()
        return uuid.UUID(&#34;urn:uuid:&#34; + id)

    def set(self, value: Union[uuid.UUID, str]) -&gt; None:
        &#34;&#34;&#34;
        Explicitly set an existing UUID value.

        Args:
            value (uuid.UUID): A valid UUID to set the metric to.
        &#34;&#34;&#34;
        self._inner.set(str(value))

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[uuid.UUID]:
        id = self._inner.test_get_value()
        if id:
            return uuid.UUID(&#34;urn:uuid:&#34; + id)
        else:
            return None

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"><p>This implements the developer facing API for recording UUID metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The UUID API exposes the <code><a title="glean.metrics.UuidMetricType.generate_and_set" href="#glean.metrics.UuidMetricType.generate_and_set">UuidMetricType.generate_and_set()</a></code> and
<code><a title="glean.metrics.UuidMetricType.set" href="#glean.metrics.UuidMetricType.set">UuidMetricType.set()</a></code> methods.</p></div>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.UuidMetricType.generate_and_set"><code class="name flex">
<span>def <span class="ident">generate_and_set</span></span>(<span>self) ‑> uuid.UUID | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_and_set(self) -&gt; Optional[uuid.UUID]:
    &#34;&#34;&#34;
    Generate a new UUID value and set it in the metric store.
    &#34;&#34;&#34;
    id = self._inner.generate_and_set()
    return uuid.UUID(&#34;urn:uuid:&#34; + id)</code></pre>
</details>
<div class="desc"><p>Generate a new UUID value and set it in the metric store.</p></div>
</dd>
<dt id="glean.metrics.UuidMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: uuid.UUID | str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: Union[uuid.UUID, str]) -&gt; None:
    &#34;&#34;&#34;
    Explicitly set an existing UUID value.

    Args:
        value (uuid.UUID): A valid UUID to set the metric to.
    &#34;&#34;&#34;
    self._inner.set(str(value))</code></pre>
</details>
<div class="desc"><p>Explicitly set an existing UUID value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>uuid.UUID</code></dt>
<dd>A valid UUID to set the metric to.</dd>
</dl></div>
</dd>
<dt id="glean.metrics.UuidMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.glean.ErrorType) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.UuidMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: str | None = None) ‑> uuid.UUID | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[uuid.UUID]:
    id = self._inner.test_get_value()
    if id:
        return uuid.UUID(&#34;urn:uuid:&#34; + id)
    else:
        return None</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="glean" href="../index.html">glean</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="glean.metrics.datetime" href="datetime.html">glean.metrics.datetime</a></code></li>
<li><code><a title="glean.metrics.event" href="event.html">glean.metrics.event</a></code></li>
<li><code><a title="glean.metrics.labeled" href="labeled.html">glean.metrics.labeled</a></code></li>
<li><code><a title="glean.metrics.object" href="object.html">glean.metrics.object</a></code></li>
<li><code><a title="glean.metrics.ping" href="ping.html">glean.metrics.ping</a></code></li>
<li><code><a title="glean.metrics.string" href="string.html">glean.metrics.string</a></code></li>
<li><code><a title="glean.metrics.timespan" href="timespan.html">glean.metrics.timespan</a></code></li>
<li><code><a title="glean.metrics.timing_distribution" href="timing_distribution.html">glean.metrics.timing_distribution</a></code></li>
<li><code><a title="glean.metrics.url" href="url.html">glean.metrics.url</a></code></li>
<li><code><a title="glean.metrics.uuid" href="uuid.html">glean.metrics.uuid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="glean.metrics.AttributionMetrics" href="#glean.metrics.AttributionMetrics">AttributionMetrics</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.AttributionMetrics.campaign" href="#glean.metrics.AttributionMetrics.campaign">campaign</a></code></li>
<li><code><a title="glean.metrics.AttributionMetrics.content" href="#glean.metrics.AttributionMetrics.content">content</a></code></li>
<li><code><a title="glean.metrics.AttributionMetrics.medium" href="#glean.metrics.AttributionMetrics.medium">medium</a></code></li>
<li><code><a title="glean.metrics.AttributionMetrics.source" href="#glean.metrics.AttributionMetrics.source">source</a></code></li>
<li><code><a title="glean.metrics.AttributionMetrics.term" href="#glean.metrics.AttributionMetrics.term">term</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.BooleanMetric" href="#glean.metrics.BooleanMetric">BooleanMetric</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.BooleanMetric.set" href="#glean.metrics.BooleanMetric.set">set</a></code></li>
<li><code><a title="glean.metrics.BooleanMetric.test_get_num_recorded_errors" href="#glean.metrics.BooleanMetric.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.BooleanMetric.test_get_value" href="#glean.metrics.BooleanMetric.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.CommonMetricData" href="#glean.metrics.CommonMetricData">CommonMetricData</a></code></h4>
<ul class="two-column">
<li><code><a title="glean.metrics.CommonMetricData.category" href="#glean.metrics.CommonMetricData.category">category</a></code></li>
<li><code><a title="glean.metrics.CommonMetricData.disabled" href="#glean.metrics.CommonMetricData.disabled">disabled</a></code></li>
<li><code><a title="glean.metrics.CommonMetricData.dynamic_label" href="#glean.metrics.CommonMetricData.dynamic_label">dynamic_label</a></code></li>
<li><code><a title="glean.metrics.CommonMetricData.lifetime" href="#glean.metrics.CommonMetricData.lifetime">lifetime</a></code></li>
<li><code><a title="glean.metrics.CommonMetricData.name" href="#glean.metrics.CommonMetricData.name">name</a></code></li>
<li><code><a title="glean.metrics.CommonMetricData.send_in_pings" href="#glean.metrics.CommonMetricData.send_in_pings">send_in_pings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.CounterMetric" href="#glean.metrics.CounterMetric">CounterMetric</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.CounterMetric.add" href="#glean.metrics.CounterMetric.add">add</a></code></li>
<li><code><a title="glean.metrics.CounterMetric.test_get_num_recorded_errors" href="#glean.metrics.CounterMetric.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.CounterMetric.test_get_value" href="#glean.metrics.CounterMetric.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.DatetimeMetricType" href="#glean.metrics.DatetimeMetricType">DatetimeMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.DatetimeMetricType.set" href="#glean.metrics.DatetimeMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.DatetimeMetricType.test_get_num_recorded_errors" href="#glean.metrics.DatetimeMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.DatetimeMetricType.test_get_value" href="#glean.metrics.DatetimeMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.DatetimeMetricType.test_get_value_as_str" href="#glean.metrics.DatetimeMetricType.test_get_value_as_str">test_get_value_as_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.DistributionMetrics" href="#glean.metrics.DistributionMetrics">DistributionMetrics</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.DistributionMetrics.name" href="#glean.metrics.DistributionMetrics.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.EventExtras" href="#glean.metrics.EventExtras">EventExtras</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.EventExtras.to_ffi_extra" href="#glean.metrics.EventExtras.to_ffi_extra">to_ffi_extra</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.EventMetricType" href="#glean.metrics.EventMetricType">EventMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.EventMetricType.record" href="#glean.metrics.EventMetricType.record">record</a></code></li>
<li><code><a title="glean.metrics.EventMetricType.test_get_num_recorded_errors" href="#glean.metrics.EventMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.EventMetricType.test_get_value" href="#glean.metrics.EventMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledBooleanMetricType" href="#glean.metrics.LabeledBooleanMetricType">LabeledBooleanMetricType</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledCounterMetricType" href="#glean.metrics.LabeledCounterMetricType">LabeledCounterMetricType</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledMetricData" href="#glean.metrics.LabeledMetricData">LabeledMetricData</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.LabeledMetricData.COMMON" href="#glean.metrics.LabeledMetricData.COMMON">COMMON</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.CUSTOM_DISTRIBUTION" href="#glean.metrics.LabeledMetricData.CUSTOM_DISTRIBUTION">CUSTOM_DISTRIBUTION</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.MEMORY_DISTRIBUTION" href="#glean.metrics.LabeledMetricData.MEMORY_DISTRIBUTION">MEMORY_DISTRIBUTION</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.TIMING_DISTRIBUTION" href="#glean.metrics.LabeledMetricData.TIMING_DISTRIBUTION">TIMING_DISTRIBUTION</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.is_COMMON" href="#glean.metrics.LabeledMetricData.is_COMMON">is_COMMON</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.is_CUSTOM_DISTRIBUTION" href="#glean.metrics.LabeledMetricData.is_CUSTOM_DISTRIBUTION">is_CUSTOM_DISTRIBUTION</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.is_MEMORY_DISTRIBUTION" href="#glean.metrics.LabeledMetricData.is_MEMORY_DISTRIBUTION">is_MEMORY_DISTRIBUTION</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.is_TIMING_DISTRIBUTION" href="#glean.metrics.LabeledMetricData.is_TIMING_DISTRIBUTION">is_TIMING_DISTRIBUTION</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.is_common" href="#glean.metrics.LabeledMetricData.is_common">is_common</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.is_custom_distribution" href="#glean.metrics.LabeledMetricData.is_custom_distribution">is_custom_distribution</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.is_memory_distribution" href="#glean.metrics.LabeledMetricData.is_memory_distribution">is_memory_distribution</a></code></li>
<li><code><a title="glean.metrics.LabeledMetricData.is_timing_distribution" href="#glean.metrics.LabeledMetricData.is_timing_distribution">is_timing_distribution</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledQuantityMetricType" href="#glean.metrics.LabeledQuantityMetricType">LabeledQuantityMetricType</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledStringMetricType" href="#glean.metrics.LabeledStringMetricType">LabeledStringMetricType</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.Lifetime" href="#glean.metrics.Lifetime">Lifetime</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.Lifetime.APPLICATION" href="#glean.metrics.Lifetime.APPLICATION">APPLICATION</a></code></li>
<li><code><a title="glean.metrics.Lifetime.PING" href="#glean.metrics.Lifetime.PING">PING</a></code></li>
<li><code><a title="glean.metrics.Lifetime.USER" href="#glean.metrics.Lifetime.USER">USER</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.MemoryDistributionMetric" href="#glean.metrics.MemoryDistributionMetric">MemoryDistributionMetric</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.MemoryDistributionMetric.accumulate" href="#glean.metrics.MemoryDistributionMetric.accumulate">accumulate</a></code></li>
<li><code><a title="glean.metrics.MemoryDistributionMetric.accumulate_samples" href="#glean.metrics.MemoryDistributionMetric.accumulate_samples">accumulate_samples</a></code></li>
<li><code><a title="glean.metrics.MemoryDistributionMetric.test_get_num_recorded_errors" href="#glean.metrics.MemoryDistributionMetric.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.MemoryDistributionMetric.test_get_value" href="#glean.metrics.MemoryDistributionMetric.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.MemoryUnit" href="#glean.metrics.MemoryUnit">MemoryUnit</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.MemoryUnit.BYTE" href="#glean.metrics.MemoryUnit.BYTE">BYTE</a></code></li>
<li><code><a title="glean.metrics.MemoryUnit.GIGABYTE" href="#glean.metrics.MemoryUnit.GIGABYTE">GIGABYTE</a></code></li>
<li><code><a title="glean.metrics.MemoryUnit.KILOBYTE" href="#glean.metrics.MemoryUnit.KILOBYTE">KILOBYTE</a></code></li>
<li><code><a title="glean.metrics.MemoryUnit.MEGABYTE" href="#glean.metrics.MemoryUnit.MEGABYTE">MEGABYTE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.ObjectMetricType" href="#glean.metrics.ObjectMetricType">ObjectMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.ObjectMetricType.set" href="#glean.metrics.ObjectMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.ObjectMetricType.test_get_num_recorded_errors" href="#glean.metrics.ObjectMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.ObjectMetricType.test_get_value" href="#glean.metrics.ObjectMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.ObjectSerialize" href="#glean.metrics.ObjectSerialize">ObjectSerialize</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.ObjectSerialize.into_serialized_object" href="#glean.metrics.ObjectSerialize.into_serialized_object">into_serialized_object</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.PingType" href="#glean.metrics.PingType">PingType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.PingType.set_enabled" href="#glean.metrics.PingType.set_enabled">set_enabled</a></code></li>
<li><code><a title="glean.metrics.PingType.submit" href="#glean.metrics.PingType.submit">submit</a></code></li>
<li><code><a title="glean.metrics.PingType.test_before_next_submit" href="#glean.metrics.PingType.test_before_next_submit">test_before_next_submit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.QuantityMetric" href="#glean.metrics.QuantityMetric">QuantityMetric</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.QuantityMetric.set" href="#glean.metrics.QuantityMetric.set">set</a></code></li>
<li><code><a title="glean.metrics.QuantityMetric.test_get_num_recorded_errors" href="#glean.metrics.QuantityMetric.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.QuantityMetric.test_get_value" href="#glean.metrics.QuantityMetric.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.RecordedEvent" href="#glean.metrics.RecordedEvent">RecordedEvent</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.RecordedEvent.category" href="#glean.metrics.RecordedEvent.category">category</a></code></li>
<li><code><a title="glean.metrics.RecordedEvent.extra" href="#glean.metrics.RecordedEvent.extra">extra</a></code></li>
<li><code><a title="glean.metrics.RecordedEvent.name" href="#glean.metrics.RecordedEvent.name">name</a></code></li>
<li><code><a title="glean.metrics.RecordedEvent.timestamp" href="#glean.metrics.RecordedEvent.timestamp">timestamp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.RecordedExperiment" href="#glean.metrics.RecordedExperiment">RecordedExperiment</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.RecordedExperiment.branch" href="#glean.metrics.RecordedExperiment.branch">branch</a></code></li>
<li><code><a title="glean.metrics.RecordedExperiment.extra" href="#glean.metrics.RecordedExperiment.extra">extra</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.StringListMetric" href="#glean.metrics.StringListMetric">StringListMetric</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.StringListMetric.add" href="#glean.metrics.StringListMetric.add">add</a></code></li>
<li><code><a title="glean.metrics.StringListMetric.set" href="#glean.metrics.StringListMetric.set">set</a></code></li>
<li><code><a title="glean.metrics.StringListMetric.test_get_num_recorded_errors" href="#glean.metrics.StringListMetric.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.StringListMetric.test_get_value" href="#glean.metrics.StringListMetric.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.StringMetricType" href="#glean.metrics.StringMetricType">StringMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.StringMetricType.set" href="#glean.metrics.StringMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.StringMetricType.test_get_num_recorded_errors" href="#glean.metrics.StringMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.StringMetricType.test_get_value" href="#glean.metrics.StringMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.TimeUnit" href="#glean.metrics.TimeUnit">TimeUnit</a></code></h4>
<ul class="two-column">
<li><code><a title="glean.metrics.TimeUnit.DAY" href="#glean.metrics.TimeUnit.DAY">DAY</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.HOUR" href="#glean.metrics.TimeUnit.HOUR">HOUR</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.MICROSECOND" href="#glean.metrics.TimeUnit.MICROSECOND">MICROSECOND</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.MILLISECOND" href="#glean.metrics.TimeUnit.MILLISECOND">MILLISECOND</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.MINUTE" href="#glean.metrics.TimeUnit.MINUTE">MINUTE</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.NANOSECOND" href="#glean.metrics.TimeUnit.NANOSECOND">NANOSECOND</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.SECOND" href="#glean.metrics.TimeUnit.SECOND">SECOND</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.TimerId" href="#glean.metrics.TimerId">TimerId</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.TimerId.id" href="#glean.metrics.TimerId.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.TimespanMetricType" href="#glean.metrics.TimespanMetricType">TimespanMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.TimespanMetricType.cancel" href="#glean.metrics.TimespanMetricType.cancel">cancel</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.measure" href="#glean.metrics.TimespanMetricType.measure">measure</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.set_raw_nanos" href="#glean.metrics.TimespanMetricType.set_raw_nanos">set_raw_nanos</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.start" href="#glean.metrics.TimespanMetricType.start">start</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.stop" href="#glean.metrics.TimespanMetricType.stop">stop</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.test_get_num_recorded_errors" href="#glean.metrics.TimespanMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.test_get_value" href="#glean.metrics.TimespanMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.TimingDistributionMetricType" href="#glean.metrics.TimingDistributionMetricType">TimingDistributionMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.TimingDistributionMetricType.accumulate_samples" href="#glean.metrics.TimingDistributionMetricType.accumulate_samples">accumulate_samples</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.accumulate_single_sample" href="#glean.metrics.TimingDistributionMetricType.accumulate_single_sample">accumulate_single_sample</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.cancel" href="#glean.metrics.TimingDistributionMetricType.cancel">cancel</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.measure" href="#glean.metrics.TimingDistributionMetricType.measure">measure</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.start" href="#glean.metrics.TimingDistributionMetricType.start">start</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.stop_and_accumulate" href="#glean.metrics.TimingDistributionMetricType.stop_and_accumulate">stop_and_accumulate</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.test_get_num_recorded_errors" href="#glean.metrics.TimingDistributionMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.test_get_value" href="#glean.metrics.TimingDistributionMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.UrlMetricType" href="#glean.metrics.UrlMetricType">UrlMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.UrlMetricType.set" href="#glean.metrics.UrlMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.UrlMetricType.test_get_num_recorded_errors" href="#glean.metrics.UrlMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.UrlMetricType.test_get_value" href="#glean.metrics.UrlMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.UuidMetricType" href="#glean.metrics.UuidMetricType">UuidMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.UuidMetricType.generate_and_set" href="#glean.metrics.UuidMetricType.generate_and_set">generate_and_set</a></code></li>
<li><code><a title="glean.metrics.UuidMetricType.set" href="#glean.metrics.UuidMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.UuidMetricType.test_get_num_recorded_errors" href="#glean.metrics.UuidMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.UuidMetricType.test_get_value" href="#glean.metrics.UuidMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
