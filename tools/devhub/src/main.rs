use std::fs::File;
use std::io::{Seek, Write};
use std::time::SystemTime;
use std::{env, io};
use std::{fs::OpenOptions, path::PathBuf};

use deps::Dependencies;
use serde::{Deserialize, Serialize};
use xshell::{Shell, cmd};

mod benchmarks;
mod build_metrics;
mod deps;

use benchmarks::Benchmark;
use build_metrics::{Codesize, MetricCount};

type Result<T, E = Box<dyn std::error::Error>> = std::result::Result<T, E>;

mod flags {
    use std::path::PathBuf;

    xflags::xflags! {
        src "./src/main.rs"

        /// Devhub helper tool.
        ///
        /// Gather various metrics from the Glean repository and upload it to the glean-devhubdb.
        cmd devhub {
            /// Output file. Default: data.json
            optional -o, --output output: PathBuf

            /// Enable only the listed metrics (comma or space-separated)
            optional -m, --metrics metrics: String

            /// Gather metrics for the `HEAD` commit in the current directory
            cmd run {
            }

            /// Commit new data and push back to the database repository
            ///
            /// Requires a valid token in the `DEVHUBDB_TOKEN` environment variable.
            cmd commit {
                /// Path to the data file to commit.
                required data_file: PathBuf
            }

            /// List all available metrics
            cmd list-metrics {
            }

            /// Backfill data for a given repository and the given revision set.
            ///
            /// Clones or fetches the repository and iterates through all commits in `revset`,
            /// runing the metric recorders for every commit.
            cmd backfill {
                /// The revset to pick. Passed on to `revset` to determine commits to examine.
                /// If unspecified, uses `HEAD^..HEAD` (only the latest commit).
                optional -r, --revset commit: String

                /// Repository URL to clone from
                required -u, --url url: String

                /// Path to clone the repository into
                required -p, --path path: PathBuf
            }
        }
    }
    // generated start
    // The following code is generated by `xflags` macro.
    // Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
    #[derive(Debug)]
    pub struct Devhub {
        pub output: Option<PathBuf>,
        pub metrics: Option<String>,
        pub subcommand: DevhubCmd,
    }

    #[derive(Debug)]
    pub enum DevhubCmd {
        Run(Run),
        Commit(Commit),
        ListMetrics(ListMetrics),
        Backfill(Backfill),
    }

    #[derive(Debug)]
    pub struct Run;

    #[derive(Debug)]
    pub struct Commit {
        pub data_file: PathBuf,
    }

    #[derive(Debug)]
    pub struct ListMetrics;

    #[derive(Debug)]
    pub struct Backfill {
        pub revset: Option<String>,
        pub url: String,
        pub path: PathBuf,
    }

    impl Devhub {
        #[allow(dead_code)]
        pub fn from_env_or_exit() -> Self {
            Self::from_env_or_exit_()
        }

        #[allow(dead_code)]
        pub fn from_env() -> xflags::Result<Self> {
            Self::from_env_()
        }

        #[allow(dead_code)]
        pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
            Self::from_vec_(args)
        }
    }
    // generated end
}

impl flags::Run {
    fn run(self, output: PathBuf, metric_recorders: &[&dyn MetricRecorder]) -> Result<()> {
        let sh = Shell::new()?;

        let data_file = OpenOptions::new().append(true).create(true).open(output)?;

        run_on_commit(&sh, &data_file, "HEAD", metric_recorders)?;

        Ok(())
    }
}

impl flags::Commit {
    fn run(self, _output: PathBuf, _metric_recorders: &[&dyn MetricRecorder]) -> Result<()> {
        let sh = Shell::new()?;
        let token = env::var("DEVHUBDB_TOKEN")
            .map_err(|_| "Missing environment variable 'DEVHUBDB_TOKEN")?;

        let url = format!("https://oauth2:{token}@github.com/mozilla/glean-devhubdb.git");
        let mut clone_cmd = cmd!(sh, "git clone --single-branch --depth 1 {url} devhubdb");
        // Contains the token, should not be printed.
        clone_cmd.set_secret(true);
        clone_cmd.run()?;

        sh.change_dir("devhubdb");

        let mut input = File::open(self.data_file)?;

        // Try up to 32 times in case a concurrent run pushes before us.
        let mut pushed = false;
        for _ in 0..32 {
            cmd!(sh, "git fetch origin main").run()?;
            cmd!(sh, "git reset --hard origin/main").run()?;

            {
                // Copy input file to the end of `data.json`
                input.seek(std::io::SeekFrom::Start(0))?;
                let mut file = OpenOptions::new()
                    .append(true)
                    .open("./devhubdb/devhub/data.json")?;
                io::copy(&mut input, &mut file)?;
            }

            cmd!(sh, "git add devhub/data.json").run()?;
            cmd!(sh, "git commit -m ðŸ“ˆ").run()?;
            match cmd!(sh, "git push").run() {
                Ok(_) => {
                    println!("metrics uploaded");
                    pushed = true;
                    break;
                }
                Err(_) => {
                    println!("conflict on push, retrying.");
                }
            }
        }

        if !pushed {
            return Err("can't push new data to github".into());
        }

        Ok(())
    }
}

impl flags::Backfill {
    fn run(self, output: PathBuf, metric_recorders: &[&dyn MetricRecorder]) -> Result<()> {
        let repo = self.path;

        let sh = Shell::new()?;

        let commits = {
            if repo.is_dir() {
                sh.change_dir(&repo);
                cmd!(sh, "git fetch origin").run()?;
            } else {
                let url = self.url;
                cmd!(sh, "git clone {url} {repo} --branch main").run()?;
                sh.change_dir(&repo);
            }
            let revset = self.revset.unwrap_or_else(|| String::from("HEAD^..HEAD"));
            cmd!(sh, "git rev-list {revset}").read()?
        };

        let commits = commits.lines().rev().collect::<Vec<_>>();
        println!("Found {} commits", commits.len());

        let data_file = OpenOptions::new().append(true).create(true).open(output)?;

        let commit_len = commits.len();
        for (idx, commit) in commits.iter().enumerate() {
            println!("{}/{}: Checking out {commit}", idx + 1, commit_len);
            cmd!(sh, "git reset --hard {commit}").run()?;

            run_on_commit(&sh, &data_file, commit, metric_recorders)?;
        }

        Ok(())
    }
}

fn main() -> Result<()> {
    use flags::DevhubCmd::*;

    let flags = match flags::Devhub::from_env() {
        Ok(flags) => flags,
        Err(err) => err.exit(),
    };

    let out_path = flags.output.unwrap_or_else(|| PathBuf::from("data.json"));

    let enabled_metrics = flags.metrics.unwrap_or_else(|| String::from(""));
    let enabled_metrics = enabled_metrics
        .split([' ', ','])
        .filter(|&s| !s.is_empty())
        .collect::<Vec<_>>();

    let metric_recorders = &[
        &Codesize as &dyn MetricRecorder,
        &MetricCount,
        &Benchmark,
        &Dependencies::new("glean-core"),
        &Dependencies::new("glean"),
    ];

    if let ListMetrics(_) = flags.subcommand {
        for recorder in metric_recorders {
            println!("{}:\t{}", recorder.name(), recorder.description());
        }

        return Ok(());
    }

    let metric_recorders = metric_recorders
        .iter()
        .flat_map(|&recorder| {
            if enabled_metrics.is_empty() || enabled_metrics.contains(&recorder.name()) {
                Some(recorder)
            } else {
                None
            }
        })
        .collect::<Vec<_>>();

    match flags.subcommand {
        Run(r) => r.run(out_path, &metric_recorders),
        Commit(c) => c.run(out_path, &metric_recorders),
        Backfill(b) => b.run(out_path, &metric_recorders),
        ListMetrics(_) => unreachable!(),
    }
}

trait MetricRecorder {
    fn record(&self, sh: &Shell) -> Result<Vec<Metric>>;

    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
}

fn run_on_commit(
    sh: &Shell,
    mut data_file: &File,
    commit: &str,
    metric_recorders: &[&dyn MetricRecorder],
) -> Result<()> {
    let wall_clock_timestamp = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();

    let timestamp = cmd!(sh, "git log --pretty=format:%ct -1 {commit}")
        .read()?
        .parse()?;

    let mut batch = MetricBatch {
        timestamp,
        metrics: vec![],
        attributes: Attributes {
            git_commit: commit.to_string(),
            wall_clock_timestamp,
        },
    };

    for recorder in metric_recorders {
        match recorder.record(sh) {
            Ok(metrics) => batch.metrics.extend(metrics),
            Err(e) => {
                eprintln!(
                    "commit: {commit} - failed to run recorder {}, error: {:?}",
                    recorder.name(),
                    e
                );
            }
        }
    }

    if !batch.metrics.is_empty() {
        writeln!(data_file, "{}", serde_json::to_string(&batch)?)?;
        data_file.sync_all()?;
    }

    Ok(())
}

#[derive(Serialize, Deserialize)]
struct MetricBatch {
    timestamp: u64,
    metrics: Vec<Metric>,
    attributes: Attributes,
}

#[derive(Serialize, Deserialize)]
struct Attributes {
    git_commit: String,
    wall_clock_timestamp: u64,
}

#[derive(Serialize, Deserialize)]
struct Metric {
    name: String,
    unit: String,
    value: u64,
}
